#!/usr/bin/env bash

# Exit if we encounter an error
set -e

HERE=$PWD
PYTHON_SCRIPTS_DIR=../python
C_BINARIES_DIR=../C

# Let us add our scripts and binary folders to the path
# This way we can call scripts and binaries directly
export PATH=$PYTHON_SCRIPTS_DIR:$PATH
export PATH=$C_BINARIES_DIR:$PATH

# Activate our Python environment
source $PYTHON_SCRIPTS_DIR/venv/bin/activate

# Lets say hello to see if all packages are in order
hello.py
echo "--------------------"

# Run the types example script
echo "Running `(which hello_types.py)`"
hello_types.py

echo "--------------------"

echo "Compiling C code with `(which cc)`"
cd $C_BINARIES_DIR
cc -Werror -Wextra -pedantic types.c -o types.exe
cd $HERE

echo "Running `(which types.exe)`"
types.exe
echo "--------------------"

echo "List of files generated by python"
ls -la *.raw
echo "--------------------"

sizes=`ls -la *.raw | awk '{print $5}'`
echo "Size of the files are listed in the fifth column and are:" 
echo "${sizes[@]}" 
echo "Bytes, respectively." 
echo "--------------------"

# `od` is a command line tool which we can use to 
# inspect the content of binary files. Useful for 
# checking if the content written to disk is what
# we expect.
# On the left we have octal offsets of the bytes in
# the binary data (14 is equal to 12 in decimal units).
# Use `man od` for more details

echo "Printing array content with \"od\""
echo "int32 array"
echo ""
od -i array.int32.raw
echo "--------------------"

echo "int64 array"
echo ""
od -I array.int64.raw
echo "--------------------"

echo "float32 array"
echo ""
od -f array.float32.raw
echo "--------------------"

echo "float64 array"
echo ""
od -F array.float64.raw
echo "--------------------"

# Remove the example binary files
rm array.*.raw
rm $C_BINARIES_DIR/types.exe

# Deactivate our python environment
deactivate

